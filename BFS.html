<html>
<head>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.5.6/p5.min.js"></script>
</head>
<body>
<canvas id="canvas1"> </canvas>
<!-- <button type="button"> Next </button> -->

<div id="popup" style="display: none"> </div>

<form name ="show">
        <input type="text" name="mouseXField" value="0" size="6"> X<br>
        <input type="text" name="mouseYField" value="0" size="6"> Y<br>
		<input type="text" name="Color" value="0" size="6"> color<br>
		<input type="text" name="Id" value="0" size="6"> id<br>
		<input type="text" name="Distance" value="0" size="6"> dist<br>
</form>


<script type="application/javascript" language="javascript">

// Hover over node to get info?

// Not working
function sleep(ms){
	return new Promise(resolve => setTimeout(resolve, ms));
}

var node = function(x, y, c, id, xi, yi){ // 0,0,white = Array[0][0]
	this.cordX = x;
	this.cordY = y;
	this.color = c;
	this.id = id;
	this.indexY = yi; // index in ArrayOfNodes...
	this.indexX = xi;
	this.predec = 0;
	this.distance = 0; // From the source node
};

var main = function(){
	this.ArrayOfNodes = [];
	this.adjList = [];
	this.w = 1000;
	this.h = 1000;
	this.step = 20; 
	canvasElementId = "canvas1";
	canvas = document.getElementById(canvasElementId);
	canvas.width  = this.w;
	canvas.height = this.h;
	this.ctx = canvas.getContext('2d');
};

main.prototype.getMousePos = function(canvas, evt){
	var rect = canvas.getBoundingClientRect(); 
	root = document.documentElement;
    // return relative mouse position
    var mouseX = Math.floor((evt.clientX - rect.left - root.scrollLeft)/20);
    var mouseY = Math.floor((evt.clientY - rect.top - root.scrollTop)/20);
    return {
		x: mouseX,
		y: mouseY,
	    root: root
    };
}

window.onload = function() {
	var mousePos = 0;
    canvas.addEventListener('mousemove', function(evt) {
		mousePos = main1.getMousePos(canvas, evt);
		var message = "Mouse position: " + mousePos.x + "," + mousePos.y;
		
		document.show.mouseXField.value = mousePos.x;
		document.show.mouseYField.value = mousePos.y;
		
		var n = main1.getGrid(mousePos.x, mousePos.y);
		document.show.Color.value = n.color;
		document.show.Id.value = n.id;
		document.show.Distance.value = n.distance;
		
		//console.log(message);
		//console.log(main1.getGrid(mousePos.x, mousePos.y).color);
    }, false);
	/*
	var e = document.getElementById('canvas1');
	
	e.onmouseover = function() {
		document.getElementById('popup').style.display = 'block';
	}
	e.onmouseout = function() {
		document.getElementById('popup').style.display = 'none';
		var myNode = document.getElementById("popup");
		while(myNode.firstChild){
			myNode.removeChild(myNode.firstChild);
		}
	}
	*/
};

main.prototype.initArrayOfNodes = function(ArrayOfNodes, wi, he, step){
	id = 0;
	for(y=0; y<(he/step); y++){ // [x][y](cordX,cordY,color)
		ArrayOfNodes[y] = [];
		for(x=0; x<(wi/step); x++){
			n = new node(x*20,y*20,"white", id, y, x);
			ArrayOfNodes[y][x] = n;
			main1.fillGrid(main1.ctx, n.indexX, n.indexY, "green");
			id++;
		};
	};
};

main.prototype.drawGrid = function(ctx, w, h, step) {
    ctx.beginPath(); 
	// Vertical
    for (var x=0; x<=w; x+=step) {
            ctx.moveTo(x, 0);
            ctx.lineTo(x, h);
    }
    ctx.lineWidth = 1;
    ctx.stroke(); 
    ctx.beginPath(); 
	// Horizontal
    for (var y=0; y<=h; y+=step) {
            ctx.moveTo(0, y);
            ctx.lineTo(w, y);
    }
    ctx.lineWidth = 1;
    ctx.stroke(); 
};

main.prototype.fillGrid = function(ctx, cordx, cordy, color){
	ctx.fillStyle = color;
	ctx.fillRect(main1.ArrayOfNodes[cordx][cordy].cordX,
				 main1.ArrayOfNodes[cordx][cordy].cordY,
				 20,20);
	main1.ArrayOfNodes[cordx][cordy].color = color;
	ctx.fillStyle = "black"
};

main.prototype.showCurrent = function(ctx, cordx, cordy){
	ctx.fillStyle = "black";
	ctx.fillRect(main1.ArrayOfNodes[cordx][cordy].cordX+10,
				 main1.ArrayOfNodes[cordx][cordy].cordY+10,
				 2,2); // Draw a dot
	ctx.fillStyle = "black"
};

main.prototype.getGrid = function(cordx, cordy, w, h){
	// w = 800 -> w = 39
	if( ((cordx < 0) || (cordy < 0) || (cordx > main1.ArrayOfNodes.length-1) || (cordy > main1.ArrayOfNodes.length-1)) ){ // 39, w, h,
		return false;
	} else {
	//if(typeof ArrayOfNodes[cordy][cordx] !== 'undefined'){
		return main1.ArrayOfNodes[cordy][cordx];
	}
};

main.prototype.getGridById = function(id){
	var flat = [].concat.apply([], main1.ArrayOfNodes);
	/*
	var col = flat.indexOf(id);
	var row = -1;
	if (col != -1) // found, now need to extract the row
	  while (main1.ArrayOfNodes[++row].length >= col) // not this row
		col -= main1.ArrayOfNodes[row].length; // so adjust and try again
	*/
	var filtered = flat.filter(function(element){ // New array
		return element.id === id;
	})
	return filtered[0];
}

/*
// Each index corresponds to a node and its neighbours.
// Useless!

main.prototype.initAdjList = function(ArrayOfNodes){ // Check a square around the node.
	for(i=0; i<ArrayOfNodes.length-1; i++){
		for(j=0; j<ArrayOfNodes[i].length-1; j++){
			var node = main1.checkNeighbours(j, i);
			if(node != false){
				var filtered = node.filter(function(element){ // New array
					return element.color !== "green"
				});
				var nodeId = { // Necessary?
					id:main1.getGrid(j,i).id,
					neighbour:filtered,
					x:i,
					y:j,
				}
				main1.adjList.push(nodeId);
			}
		}
	}
};
*/

main.prototype.checkNeighbours = function(cordx, cordy) {
	if(main1.getGrid(cordx, cordy, main1.w, main1.h).color == "green"){ // Check for grey aswell, since they have already been visited?
		return false;
	}
	var neighbour = []
	// Top-left
	if(main1.getGrid(cordx-1, cordy-1, main1.w, main1.h) != false){
		//return getGrid(cordx-1, cordy-1).color;
		
		//neighbour.push(main1.getGrid(cordx-1, cordy-1)); // Comment out to check diagonally!
		
		//console.log(main1.getGrid(cordx-1, cordy-1))
		//console.log("TOP-LEFT");
	}
	// Top
	if(main1.getGrid(cordx, cordy-1, main1.w, main1.h) != false){
		//return getGrid(cordx, cordy-1).color;
		neighbour.push(main1.getGrid(cordx, cordy-1, main1.w, main1.h));
		//console.log("TOP");
	}
	// Top-right
	if(main1.getGrid(cordx+1, cordy-1, main1.w, main1.h) != false){
		//return getGrid(cordx+1, cordy-1).color;
		
		//neighbour.push(main1.getGrid(cordx+1, cordy-1)); // Comment out to check diagonally!
		
		//console.log("TOP-RIGHT");
	}
	// Left
	if(main1.getGrid(cordx-1, cordy, main1.w, main1.h) != false){
		//return getGrid(cordx-1, cordy).color;
		neighbour.push(main1.getGrid(cordx-1, cordy, main1.w, main1.h));
		//console.log("LEFT");
	}
	// Right
	if(main1.getGrid(cordx+1, cordy, main1.w, main1.h) != false){
		//return getGrid(cordx+1, cordy).color;
		neighbour.push(main1.getGrid(cordx+1, cordy, main1.w, main1.h));
		//console.log("RIGHT");
	}
	// Bottom-left
	if(main1.getGrid(cordx-1, cordy+1, main1.w, main1.h) != false){
		//return getGrid(cordx-1, cordy+1).color;
		
		//neighbour.push(main1.getGrid(cordx-1, cordy+1)); // Comment out to check diagonally!
		
		//console.log("BOTTOM-LEFT");
	}
	// Bottom
	if(main1.getGrid(cordx, cordy+1, main1.w, main1.h) != false){
		//return getGrid(cordx, cordy+1).color;
		neighbour.push(main1.getGrid(cordx, cordy+1, main1.w, main1.h));
		//console.log("BOTTOM");
	}
	// Bottom-right
	if(main1.getGrid(cordx+1, cordy+1, main1.w, main1.h) != false){
		//return getGrid(cordx+1, cordy+1).color;
		
		//neighbour.push(main1.getGrid(cordx+1, cordy+1)); // Comment out to check diagonally!
		
		//console.log("BOTTOM-RIGHT");
	}
	if(neighbour.length == 0){
		return false;
	} else {
		var filtered = neighbour.filter(function(element){ // New array
		return element.color !== "green"
		});
		return filtered;
	}
};

main.prototype.randomPos = function(){ // Wrong? Cant get 0?
	return [Math.floor(Math.random() * main1.ArrayOfNodes.length-1) + 1 , Math.floor(Math.random() * main1.ArrayOfNodes.length-1) + 1 ]; // 39
};

main.prototype.showPath = function(node){
	while(node.color !== "red"){
		main1.fillGrid(main1.ctx, node.indexX, node.indexY, "purple");
		node = main1.getGridById(node.predec);
	}
}

main.prototype.BFS = function(startPos, adjlist){
	var sinkfound = 0;
	var startItem = [startPos]; // ENQUEUE(Q,s)
	//var timer;
	while(sinkfound != 1){ // true
		//timer = setTimeout(main1.BFS, 1000);
		var nodeInUse = startItem.shift(); // u = DEQUEUE(Q), remove from front
		main1.showCurrent(main1.ctx, nodeInUse.indexX, nodeInUse.indexY);
		nodeNeighbour = main1.checkNeighbours(nodeInUse.indexY, nodeInUse.indexX);

		// for each v in G.Adj[u]
		for(i=0; i<nodeNeighbour.length;i++){
			var n = nodeNeighbour[i];
			if(n.color === "white"){
				main1.fillGrid(main1.ctx, n.indexX, n.indexY, "grey");
				n.predec = nodeInUse.id;
				n.distance = nodeInUse.distance + 1;
				startItem.push(n);
			} else {
				if(n.color === "blue"){
					console.log("Blue found!");
					main1.showPath(nodeInUse);
					//clearTimeout(timer);
					sinkfound = 1;
					return nodeInUse.distance+1;
				}
			}
		}
		if(nodeInUse.color !== "red"){
			main1.fillGrid(main1.ctx, nodeInUse.indexX, nodeInUse.indexY, "orange");
		} else {
			main1.fillGrid(main1.ctx, nodeInUse.indexX, nodeInUse.indexY, "red");
		}
	}
};

main.prototype.init = function(){
	var start = main1.getNonGreen();
	var end = main1.getNonGreen();
	while(start[0] === end[0] || start[1] === end[1]){
		start = main1.getNonGreen();
		end = main1.getNonGreen();
	}
	main1.fillGrid(main1.ctx, start[1], start[0], "red"); // Source , (y, x)
	main1.fillGrid(main1.ctx, end[1], end[0], "blue"); // Sink
	return start;
};

main.prototype.getNonGreen = function(){
	var randNode = main1.randomPos();
	while(main1.getGrid(randNode[0], randNode[1], main1.w, main1.h).color === "green"){
		randNode = main1.randomPos();
	}
	return randNode;
};

main.prototype.generateMaze = function(){
// Depth-first, make all node white (all begin as green?)
// Move Up, Down, Left or Right (no diagonally yet)
// Must move 2 steps!
	pos = main1.randomPos();
	start = main1.getGrid(pos[0], pos[1], main1.w, main1.h);
	main1.fillGrid(main1.ctx, start.indexX, start.indexY, "white");
	var stack = [];
	
	while(true){
		var possiblemoves = main1.searchDeadEnd(start);
		if(possiblemoves != false){
			stack.push(start);
			start = main1.randMove(possiblemoves, start);
		} else {
			if(stack.length != 0){
				start = stack.pop();
			} else {
				console.log("Done!");
				return;
			}
		}
	}
};

main.prototype.searchDeadEnd = function(node){
	var neighbour = [];
	if((main1.getGrid(node.indexY, node.indexX-2, main1.w, main1.h) != false) && (main1.getGrid(node.indexY, node.indexX-2, main1.w, main1.h).color != "white") && (main1.getGrid(node.indexY, node.indexX-1, main1.w, main1.h).color != "white")){ // Top
		//neighbour.push(main1.getGrid(node.indexY, node.indexX-2));
		neighbour.push("top");
	}
	if((main1.getGrid(node.indexY-2, node.indexX, main1.w, main1.h) != false) && (main1.getGrid(node.indexY-2, node.indexX, main1.w, main1.h).color != "white") && (main1.getGrid(node.indexY-1, node.indexX, main1.w, main1.h).color != "white")){ // Left
		//neighbour.push(main1.getGrid(node.indexY-2, node.indexX));
		neighbour.push("left");
	}
	if((main1.getGrid(node.indexY+2, node.indexX, main1.w, main1.h) != false) && (main1.getGrid(node.indexY+2, node.indexX, main1.w, main1.h).color != "white") && (main1.getGrid(node.indexY+1, node.indexX, main1.w, main1.h).color != "white")){ // Right
		//neighbour.push(main1.getGrid(node.indexY+2, node.indexX));
		neighbour.push("right");
	}
	if((main1.getGrid(node.indexY, node.indexX+2, main1.w, main1.h) != false) && (main1.getGrid(node.indexY, node.indexX+2, main1.w, main1.h).color != "white") && (main1.getGrid(node.indexY, node.indexX+1, main1.w, main1.h).color != "white")){ // Bottom
		//neighbour.push(main1.getGrid(node.indexY, node.indexX+2));
		neighbour.push("bottom");
	}
	if(neighbour.length == 0){
		return false;
	} else {
		return neighbour; // true
	}
}

main.prototype.randMove = function(nodes, node){
	// Check array (possible moves), select one randomly, (choose dep. on array size)
	// Nodes is an array of possible moves
	direction = nodes[(Math.floor(Math.random() * nodes.length) + 0)];
	
	switch (direction) { // Math.floor(Math.random() * 4) + 0
		case "top": // Top
				main1.fillGrid(main1.ctx, node.indexX-1, node.indexY, "white");
				main1.fillGrid(main1.ctx, node.indexX-2, node.indexY, "white");
				return main1.getGrid(node.indexY, node.indexX-2, main1.w, main1.h);
				
		case "left": // Left
				main1.fillGrid(main1.ctx, node.indexX, node.indexY-1, "white");
				main1.fillGrid(main1.ctx, node.indexX, node.indexY-2, "white");
				return main1.getGrid(node.indexY-2, node.indexX, main1.w, main1.h);
				
		case "right": // Right
				main1.fillGrid(main1.ctx, node.indexX, node.indexY+1, "white");
				main1.fillGrid(main1.ctx, node.indexX, node.indexY+2, "white");
				return main1.getGrid(node.indexY+2, node.indexX, main1.w, main1.h);
				
		case "bottom": // Bottom
				main1.fillGrid(main1.ctx, node.indexX+1, node.indexY, "white");
				main1.fillGrid(main1.ctx, node.indexX+2, node.indexY, "white");
				return main1.getGrid(node.indexY, node.indexX+2, main1.w, main1.h);
	}
};

// Show steps, slow down the process? Button?
var main1 = new main();

start = new Date();
main1.initArrayOfNodes(main1.ArrayOfNodes, main1.w, main1.h, main1.step);
end = new Date();

start1 = new Date();
main1.generateMaze();
stop1 = new Date();

var startpos = main1.init();

start2 = new Date();
var result = main1.BFS(main1.getGrid(startpos[0],startpos[1], main1.w, main1.h), main1.adjList);
stop2 = new Date();

console.log("initArrayOfNodes: " + (end - start)/1000);
console.log("generateMaze: " + (stop1 - start1)/1000);
console.log("BFS: " + (stop2 - start2)/1000);

main1.drawGrid(main1.ctx, main1.w, main1.h, main1.step);
//console.log("Distance to sink: " + result.toString());

</script>
</body>
</html>